<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="js/web3.min.js"></script>
    <script type="text/javascript">
        window.addEventListener('load', function () {
            if (typeof web3 !== 'undefined') {
                console.log('Web3 Injection Detected! ' + web3.currentProvider.constructor.name);
                window.web3 = new Web3(web3.currentProvider);
            } else {
                console.log('No Web3 Injection detected');
                var infura_key = sessionStorage.getItem("infura_key");
                if (infura_key == null) {
                    let prompt = window.prompt("Unable to detect a valid Web3 Provider. Please install MetaMask and try again, or, enter your INFURA API key.", "");
                    if (prompt) {
                        sessionStorage.setItem("infura_key", prompt);
                        console.log("INFURA API key stored");
                        window.web3 = new Web3(new Web3.providers.HttpProvider("https://mainnet.infura.io/" + prompt));
                    } else {
                        document.body.innerHTML = 'Please install MetaMask or obtain an INFURA API key.';
                    }
                } else {
                    window.web3 = new Web3(new Web3.providers.HttpProvider("https://mainnet.infura.io/" + infura_key));
                }
            }
            readOnly();
        });

        function getContracts() {
            var addresses = {
                Hash: "0xa7620C421d29db2bb991cD603a725b960E927cEd",
                Prover: "0x1f5cDff41Fb9B17996D6F0fcA6Ab9C5bEd96F20f"
            };
            var abis = {
                Hash: [{"constant":false,"inputs":[],"name":"selfDestruct","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"dataString","type":"string"}],"name":"hash","outputs":[{"name":"","type":"bytes32"}],"payable":false,"stateMutability":"pure","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback"}],
                Prover: [{"constant":true,"inputs":[{"name":"target","type":"address"},{"name":"dataHash","type":"bytes32"}],"name":"entryInformation","outputs":[{"name":"proved","type":"bool"},{"name":"time","type":"uint256"},{"name":"staked","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"dataHash","type":"bytes32"}],"name":"addEntry","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},{"constant":true,"inputs":[],"name":"registeredUsers","outputs":[{"name":"number_unique_addresses","type":"uint256"},{"name":"unique_addresses","type":"address[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"selfDestruct","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"target","type":"address"}],"name":"userEntries","outputs":[{"name":"","type":"bytes32[]"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"dataHash","type":"bytes32"}],"name":"deleteEntry","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"payable":false,"stateMutability":"nonpayable","type":"fallback"}]
            };
            var contracts = {
                Hash: web3.eth.contract(abis.Hash).at(addresses.Hash),
                Prover: web3.eth.contract(abis.Prover).at(addresses.Prover)
            }
            return contracts
        };

        // query specific entry
        function proveIt() {
            var address, entry, entryHash, outcome, displayString;
            var Prover = getContracts().Prover;
            var Hash = getContracts().Hash;
            address = document.getElementById("proveAddress").value
            entry = document.getElementById("proveEntry").value
            try {
                Prover.entryInformation.call(address, entry, function (error, entryInfo) {
                    if (! error) {
                        outcome = {
                            proved: entryInfo[0],
                            time: entryInfo[1].toNumber(),
                            staked: web3.fromWei(entryInfo[2].toNumber(), "ether")
                        };
                        var date = new Date(outcome.time*1000);
                        var dateOptions = {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric',
                            hour: "numeric",
                            minute: "numeric"};
                        var displayString = [];
                        displayString.push(outcome.proved ? "Proved: True" : "Proved: False");
                        displayString.push("Time: " + date.toLocaleString("en-US", dateOptions));
                        displayString.push("Staked: " + outcome.staked + " ETH");
                        document.getElementById("proved").innerHTML = displayString.join(" <br> ");
                    }
                });
            } catch (error) {
                document.getElementById("proved").innerHTML = error;
            }
        };

        // query specific entry
        function getEntries() {
            var address, entries;
            var Prover = getContracts().Prover;
            address = document.getElementById("addressQuery").value
            try {
                Prover.userEntries.call(address, function (error, entries) {
                    if (! error) {
                        document.getElementById("entries").innerHTML = entries;
                    }
                });
            } catch (error) {
                document.getElementById("entries").innerHTML = error;
            }
        };


        // populate read-only data
        function readOnly() {
            var users;
            var Prover = getContracts().Prover;
            try {
                Prover.registeredUsers.call(function (error, users) {
                    if (! error) {
                        document.getElementById("numUsers").innerHTML = users[0].toNumber();
                        document.getElementById("users").innerHTML = users[1];
                    }
                });
            } catch (error) {
                document.getElementById("numUsers").innerHTML = error;
                document.getElementById("users").innerHTML = error;
            }
        }

        function hash() {
            var message, messageHash;
            var Hash = getContracts().Hash;
            message = document.getElementById("message").value
            try {
                Hash.hash.call(message, function (error, messageHash) {
                    if (! error) {
                        document.getElementById("messageHash").innerHTML = messageHash;
                    }
                });
            } catch (err) {
                document.getElementById("messageHash").innerHTML = err;
            }
        };

    </script>
</head>

<body>
    <h1>ProveIt</h1>
    <button type="button" onClick="readOnly();">Refresh</button>
    <p>Number of Registered Addresses:</p><div id="numUsers"></div>
    <p>Registered Addresses:</p><div id="users"></div>
    <br />

    <p>Query Entries:</p>
    <input type="text" id="addressQuery" size="42" placeholder="Address 0x..."/>
    <button type="button" onClick="getEntries();">Query</button>
    <div id="entries"></div>

    <p>Hash Helper:</p>
    <input type="text" id="message" placeholder= "Your message here"/>
    <button type="button" onClick="hash();">Hash</button>
    <div id="messageHash"></div>

    <p>Prove it:</p>
    <input type="text" id="proveAddress" placeholder= "Address 0x..."/>
    <input type="text" id="proveEntry" placeholder= "Hash 0x..."/>
    <button type="button" onClick="proveIt();">Prove it!</button>
    <div id="proved"></div>
</body>

</html>
